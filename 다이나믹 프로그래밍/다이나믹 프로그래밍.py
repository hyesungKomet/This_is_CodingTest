# 시간이 많이 필요하거나 메모리 공간이 많이 필요한 문제는 해결하기 힘들다
# 대표적인 예시가 피보나치 수열!
# An = An-1 + An-2, (A1 = 1, A2 = 1)
# 1 1 2 3 5 8 13 21 ...
def fibo(x):
    if x==1 or x==2:
        return 1
    return fibo(x-1)+fibo(x-2)

print(fibo(99))

# 여기서 문제는 fibo(3)을 구하기 위해 fibo(1)+fibo(2)를 했는데
# fibo(4)를 구하기 위해서 다시 fibo(3)에서 했던 연산이 필요한 것
# x가 커질수록 이렇게 중복되는 연산량은 지수함수로 늘어난다
# x가 30만 돼도 10억 가량의 연산 필요... 시간 복잡도는 O(2^N)이다
# --> 다이나믹 프로그래밍 필요!

# <다이나믹 프로그래밍의 조건>
# 1. 큰 문제를 작은 문제로 나눌 수 있다
# 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

# Memoization(메모이제이션) 기법으로 해결!
# 구한 결과를 메모리 공간에 메모하고 이후 같은 식 필요시 거기서 호출해서 쓴다!

# 다이나믹 피로그래밍 적용시 시간 복잡도: O(N)
# 한번 구한 값은 다시 안구해도 돼서!

# 개선된 피보나치 수열 함수
d = [0] * 100

def memo_fibo(x):
    print('f('+str(x)+')', end=' ') # 호출되는 함수 확인!
    if x==1 or x==2:
        return 1
    # 계산해놓은 값이면 리스트에서 호출해서 그대로 반환
    if d[x] != 0:
        return d[x]
    # 계산하지 않았던 값이면 계산하여 리스트에 메모
    d[x] = memo_fibo(x-1) + memo_fibo(x-2)
    return d[x]

print(memo_fibo(99))


# 큰 문제를 작은 문제로 나누어 해결하는 방법은 퀵 정렬에서도 언급됐는데
# 이들의 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 주지만
# 퀵 정렬 같은 분할 정복(divide and conquer) 문제는 각각 독립적이라는 것


# 여기서 재귀 함수 사용시 컴퓨터 시스템에서는 함수 다시 호출할 때 메모리 상에
# 적재되는 일련의 과정을 따라야 하니 오버헤드 발생 가능
# --> 반복문을 이용한 다이나믹 프로그래밍이 더 성능 좋다!


# 다이나믹 프로그래밍 방식
# 1. 탑다운(Top-Down) 방식: 큰 문제 해결위해 작은 문제 호출 - 재귀 함수 이용
#   memoization와 비슷 but memoization은 이전 계산 결과를 일시적으로
#   기록한다는 넓은 개념이니 다른 개념이다

# 2. 바텀업(Bottom-Up) 방식: 작은 문제부터 차근차근 답 도출 - 반복문 이용
#   여기서 결과 저장용 리스트를 DP 테이블이라고 부른다

# 반복문 사용한(바텀업) 피보나치 수열 함수
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i-1]+d[i-2]

print(d[n]

# 사전 자료형(dict)도 메모이제이션에 유용하다
# 특히 일부의 작은 문제에 대한 해답만 필요한 경우 유용
# (솔직히 아직 이해안됨ㅋ)
# 3차원 리스트 이용해야 하는 복잡한 난이도 -> 최단 경로의 플로이드 워셜 알고
# (머라는거ㅋㅋ)

# KeyPoint
# 일단 단순히 재귀함수로 비효율적이게 짠 뒤에 메모이제이션 되도록 코드수정!
# 가능하면 재귀보단 바텀업 방식으로 반복문 사용하기!

# 재귀함수로 5000번쨰 이상 피보나치 수 구하려고 하면 recursion depth
# 관련 오류 발생 - sys.setrecursionlimit()로 제귀 제한 완화하기!













