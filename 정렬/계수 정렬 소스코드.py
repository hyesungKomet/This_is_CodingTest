# 계수 정렬
# 데이터의 최댓값과 최솟값의 차이가 크지 않을 때 매우 빠르다
# 최댓값~최솟값 범위를 크기로 하는 리스트를 만들어야하기 때문
# 최댓값, 최솟값의 차이가 1,000,000을 넘지 않을 때 효과적!
# 직접 데이터 값을 비교하는 비교 기반의 정렬 알고리즘이 아님!
# 선택, 삽입, 퀵 정렬은 다 비교 기반의 정렬 알고리즘!

# 계수 정렬의 시간 복잡도
# O(N+K) : N: 양의 정수의 데이터 수 K: 데이터 중 최댓값의 크기
# 기수 정렬과 함께 가장 빠름! (기수 정렬은 계수 정렬보다 동작 느리지만
# 처리할 수 있는 정수의 크기가 더 크다 + 출제빈도 낮음ㅎ)

# 계수 정렬의 공간 복잡도
# ex) 데이터가 0, 999999 두 개만 있을 때도 리스트의 크기는 100만개여야함
# 항상 사용은 X 동일한 값이 많을 때 적합! ex) 성적 정렬!
# 계수 정렬의 공간 복잡도는 O(N+K)

# 모든 원소의 값이 0보다 크거나 같다고 가정 + 실수 안됨! 양의 정수만!
array = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]
sorted_array = []

# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 count 인덱스의 값 +1

for i in range(len(count)):
    for j in range(count[i]):
        sorted_array.append(i)
        print(i, end='') #인덱스 해당값만큼 인덱스 출력

print(sorted_array)
